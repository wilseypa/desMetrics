#import sys
import os
import json
import pylab
import seaborn as sns
import numpy as np

#for arg in sys.argv:
#    print arg

# create a directory to write output graphs
outDir = 'outputGraphics/'
if not os.path.exists(outDir):
    os.makedirs(outDir)

#--------------------------------------------------------------------------------
# import the json file of model summary information

# read the json file
json_data = open("analysisData/modelSummary.json")
model_summary = json.load(json_data)

model_name = model_summary["model_name"]
total_lps = model_summary["total_lps"]
total_events = model_summary["total_events"]

# define a function to display/save the pylab figures.
def display_graph(fileName) :
    pylab.savefig(fileName, bbox_inches='tight')
    #pylab.savefig(fileName, bbox_inches='tight')
    pylab.show()

#--------------------------------------------------------------------------------
# plot the number of events that are available by simulation cycle

data = np.loadtxt("analysisData/eventsAvailableBySimCycle.csv", dtype=np.intc, delimiter = ",", skiprows=2)
outFile = outDir + 'eventsAvailableBySimCycle.pdf'

pylab.title('Cycle by Cycle Record of Events Available for Execution')
pylab.plot(data)
pylab.ylabel('Number of Events Available for Exec\n(log scale to minimize outlier dominance)')
pylab.yscale('log')
pylab.xlabel('Simulation Cycle (assumes instantaneous event execution)')
display_graph(outFile)

#--------------------------------------------------------------------------------
# plot a histogram of the number of simulation cycles that X events are available

# NOTE: do we need to implement a more rigorous method to outlier detection/removal?  possibly.

# reject outliers from the mean
def reject_outliers(data, m=2):
    return data[abs(data - np.mean(data)) < m * np.std(data)]

outFile = outDir + 'histogramOfEventsAvailable.pdf'
pylab.title('Histogram of Events Available for Execution (outliers removed)')
pylab.hist(reject_outliers(data), bins=50, normed=True)
pylab.xlabel('Number of Simulation Cycles')
pylab.ylabel('Number of Events (normalized, histogram integral will sum to 1)')
display_graph(outFile)

#--------------------------------------------------------------------------------
# plot the local/total events executed by each LP (sorted)

# skip the first column of LP names
data = np.loadtxt("analysisData/eventsExecutedByLP.csv", dtype=np.intc, delimiter = ",", skiprows=2, usecols=(1,2,3))
outFile = outDir + 'totalEventsProcessedByLP.pdf'

# sort the data by the total events executed
sorted_data = data[data[:,2].argsort()]

# need a vector of values for the for the x-axis
x_index = np.arange(len(data))

pylab.title('Local/Total Events processed by each LP (sorted)')
# plotting as bars exhausted memory
#pylab.bar(x_index, sorted_data[:,0], color='r', width=1.0, linewidth=0, label="Local")
#pylab.bar(x_index, sorted_data[:,1], color='b', width=1.0, linewidth=0, label="Remote", bottom=sorted_data[:,1])
pylab.plot(x_index, sorted_data[:,0], color='r', label="Local")
pylab.plot(x_index, sorted_data[:,2], color='b', label="Local+Remote (Total)")
pylab.legend(loc='upper left')
display_graph(outFile)

#--------------------------------------------------------------------------------
# histograms of events executed by each LP

local_events = []
for i in np.arange(len(data)) :
    local = float(data[i,0])
    total = float(data[i,2])
    percent = round((local / total) * 100,2)
    local_events.append(percent)

outFile = outDir + 'histogramOfLocalEventsGenerated.pdf'
pylab.title('Histogram of Events Generated by the Receiving LP')
pylab.hist(sorted(local_events), bins=100)
# turn off scientific notation on the x-axis
ax = pylab.gca()
ax.get_xaxis().get_major_formatter().set_useOffset(False)
pylab.xlabel('Percent of Executed Events that were Locally Generated')
pylab.ylabel('Number of LPs Containing Said Percentage')
display_graph(outFile)

outFile = outDir + 'historgramOfLocalAndRemoteEventsExecuted.pdf'
pylab.title('Histogram of Local/Remote Events Executed by the LPs')
pylab.hist((data[:,0], data[:,1]), histtype='barstacked', label=('Local', 'Remote'), color=('b', 'r'), bins=100)
pylab.xlabel('Number of Events')
pylab.ylabel('Number of LPs Executing Said Events')
pylab.legend(loc='best')
display_graph(outFile)

#--------------------------------------------------------------------------------
# plot the percent of local events executed by each LP

### using variables from above....

outFile = outDir + 'percentOfExecutedEventsThatAreLocal.pdf'
pylab.title('Percent of Events Executed that are Local (sorted)')
pylab.plot(x_index, sorted(local_events))
pylab.xlabel('LPs (sorted by percent local)')
pylab.ylabel('Percent of Total Executed')
pylab.ylim((0,100))
# fill the area below the line
ax = pylab.gca()
ax.fill_between(x_index, sorted(local_events), 0, facecolor='blue')
display_graph(outFile)

#--------------------------------------------------------------------------------
# display graphs of the event chain summaries

data = np.loadtxt("analysisData/eventChainsSummary.csv", dtype=np.intc, delimiter = ",", skiprows=2)
outFile = outDir + 'eventChainSummary.pdf'

bar_width = .3

pylab.title('Number Local, Linked, and Global Chains of length X')
pylab.bar(data[:,0], data[:,1], bar_width, color='b', label="Local")
pylab.bar(data[:,0] + bar_width, data[:,2], bar_width, color='g', label="Linked")
pylab.bar(data[:,0] + bar_width + bar_width, data[:,3], bar_width, color='r', label="Global")
pylab.xticks(data[:,0] + bar_width, ('1', '2', '3', '4', '>=5'))
pylab.legend(loc='best')
display_graph(outFile)

#--------------------------------------------------------------------------------
# histograms of local chains longer than 1

data = np.loadtxt("analysisData/localEventChainsByLP.csv", dtype=np.intc, delimiter = ",", skiprows=2, usecols=(1,2,3,4,5))
outFile = outDir + 'histogramOfLocalEventChains.pdf'

percent_long_chains = []
for i in np.arange(len(data)) :
    num_chains = 0
    for j in np.arange(len(data[i])) :
                        num_chains = num_chains + float(data[i,j])
    percent = round(((num_chains - float(data[i,0])) / num_chains) * 100,2)
    percent_long_chains.append(percent)
    
pylab.title('Histogram of Local Event Chains Longer than 1')
pylab.hist(sorted(percent_long_chains), bins=100)
pylab.xlabel('Percent')
pylab.ylabel('Number of LPs Containing Said Percent')
display_graph(outFile)

outFile = outDir + 'histogramOfLocalEventChainsNormalized.pdf'
pylab.title('Histogram of Local Event Chains Longer than 1')
pylab.hist(sorted(percent_long_chains), bins=100, normed=True)
pylab.xlabel('Percent')
pylab.ylabel('Frequency normalized so sum of integral is 1')
display_graph(outFile)

#--------------------------------------------------------------------------------
# plots of the number of LPs each LP receives events from

## NOTE: i believe the data file has incorrectly computed this result.  it looks like i may have accidently included local events in the total which would skew the results (smaller).  need to investigate.

# let's look at how many LPs provide 95% of the messages to each LP
# column 5 has the data we need
data = np.loadtxt("analysisData/numOfLPsToCoverPercentEventMessagesSent.csv", dtype=np.intc, delimiter = ",", skiprows=2, usecols=(4,5))
outFile = outDir + 'numberOfLPsSending95PercentOfRemoteEvents.pdf'

pylab.title('How many LPs are involved in sending 95% of remote events')
pylab.hist(data[:,1], bins=20, normed=True)
pylab.xlabel('Number of Sending LPs')
pylab.ylabel('Normalized Frequency (sum of the integral is 1)')
display_graph(outFile)



