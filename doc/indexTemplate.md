
# desMetrics Analysis Results

**I will replace the inline links with the nvd3 scripts later.**

<!-- 
  this next paragraph assumes that the tools generate a file "model_summary.html" that
  contains information on the tool, simulation model, command line arguments, and
  configuration information.  in each section below, the image name in the markdown link
  should be the name of the file generated by the analysis tool corresponding to the
  description in that section.
  -->

This page summarizes results from analyzing the characteristics of the event profile of a
discrete event simulation model.  The the model name, the tool its profile characteristics
were generated from, the date of the capture, and the relevant command line arguments and
configuration parameters are available [here](./graphs/model_summary.html).

The following analysis activities are parallel simulation centric.  Thus, we assume, for
example, that the discrete event simulation is composed of events processed by LPs.


# Characteristics of Events Received

This series of graphs examine the characteristics of events received and processed by each
LP in the system.

## Characteristics of Events Executed by each LP

This is an x-y chart that summarizes the total events processed by each LP in the
simulation.  In particular, for each LPi, the number of events processed by LPi are
classified as those generated by LPi and by any other LPj (i != j).  Sums of each class
are computed and displayed.

* x-axis: labeled "LPs", enumerates the names of the LPs in the model.

* y-axis: labeled "Total Number of Events", show the total number of events that are to be
  executed by the corresponding LP.

* Computed as: for each LP, simply sum the number of local and remote events that are with
  a "destination_LP" field corresponding to that LP.

![events_executed_by_lp](./graphs/events_executed_by_lp.pdf)

## Number of LPs Executing X Events

This an x-y chart that shows the number of LPs that process X events.  

* x-axis: labeled "Number of Events Executed" contains the integer range of events (from
  minimum to maximum) executed by any LP in the model.  For example, assume that N is the
  minimum number of events executed by a LP and M is the maximum number of events executed
  by a LP, then the x-axis will be the range N:M.

* y-axis: labeled "Number of LPs Executing X Events" shows the number of LPs that process
  that total number (the x-axis index) of events.

* Computed as: for each X, show the number of LPs that execute X total events.

![number_of_lps_executing_x_events](./graphs/number_of_lps_executing_x_events.pdf)

## Number of LPs Sending Events to LPi 

This graphic will record the number of events sent by other LPs to this LP.  This graphic
is equivalent to the sending events graphic computed below.  we should probably fold them
together.  I am leaving this description here for now.

Captured so that we can filter senders of less than X% (or X total) events.  In other
words, LPi receives at least 3 events from these LPs, 10 (or 90% of it's processed) events
from these LPs, etc.   

We cannot easily compute this in nvd3; if we move to crossfilter and dc.js, this might be
something we could compute; we might want to fold this computation into the "Total Number
of Events Executed by each LP" graphic.


# Characteristics of Events Generated

These set of graphs will summarize the communication patterns of events exchanged by two
LPs.  That is, for each LP in the system, these graphs show what other LPs that LP
generate events for.

## Number of Local and Remote Events Generated

How many local events (destined for this LP) vs remote events (destined for other LPs)
does the LP generate.  This is related to the number of local and remote events processed
graph shown above, but distinct in that it shows who is generating events for remote LPs. 

* x-axis: labeled "LPs", enumerates the names of the LPs in the model.

* y-axis: labeled "Events Generated", showing the number of local and remote events sent
  by this LP.

* Computed by: for each LP, simply sum the number of local and remote events that are with
  a "destination_LP" field of events generated by the LP.

![events_generated_by_lp](./graphs/events_generated_by_lp.pdf)


# Available Parallelism

These graphics explore the ideal values of potential parallelism in the system.  

## Total Events Available for Execution at Each Event Scheduling Cycle

**This data is just too massive to display/use.  We will use the summary data from the
  next section instead.**

Assuming a unit time execution time for all events and that all available events are
executed at once, this plot should show the number of scheduling cycles with X events
available for execution.

* x-axis: labeled "Scheduling Cycle Number".  Enumerating the scheduling cycles 1:N.

* y-axis, labeled "Number of Events Available for Execution".  Contains the range of
  events available.  The range of the x-axis is N:M, where N is the minimum number of
  events found and M is the maximum number of events found.

* Computed as: 
  
```AsciiDoc
let 1:N be the range of LPs in the simulation
for each lp[i] in the simulation, let lp[i].event_queue be a queue of events destined for that LP
total_schedule_cycles = 0;
forall i in 1:N events_available[i] = 0;
while (at least one lp[i].event_queue.empty() != NULL) {
  schedule_time = minimum { lp[i].event_queue.front().receive_time };
  foreach i such that (lp[i].event_queue.front().send_time < schedule_time) {
    events_available[schedule_time]++;
    lp[i].event_queue.pop();
  }
  total_schedule_cycles++;
}
for i in range (1:schedule_time) {
  plot i,events_available[i];
}
```

We need to preserve/report the total_schedule_cycles from the above algorithm.  It tells
us the number of unit execution cycles through the critical path.  For now I suppose it
could be displayed in the graph (if that is convenient).  Perhaps it will come up again in
another graphic (I'm assuming so, but have to think on what other graphs we may want to
generate).

![events_available_for_execution_by_scheduling_cycle](./graphs/events_available_for_execution_by_scheduling_cycle.pdf)

## Number of Event Cycles with X Events available for Execution.

Assuming a unit time execution time for all events and that all available events are
executed at once, this plot should show the number of scheduling cycles with X events
available for execution.

* x-axis, labeled "Number of Events Available for Execution".  Contains the range of
  events available.  The range of the x-axis is N:M, where N is the minimum number of
  events found and M is the maximum number of events found.

* y-axis: labeled "Number of Scheduling Cycles" Shows the number of scheduling cycles that
  number of events was available for execution.

* Computed as: summarize results events_available from graph data showing "Events
  Available for Execution by Scheduling Cycle".

![scheduling_cycles_with_x_available_events](./graphs/scheduling_cycles_with_x_available_events.pdf)

## Startup/Teardown Events

Do we want to try to see the impact of startup and teardown on events executed.  Years
ago, Peter Ashenden had a master's student show the number of events executed by delta
cycles in VHDL simulations.  The long tail of the reduced events executed during delta
cycles was startling.  Is there an equivalent characteristic in simulation setup/teardown
that has problematic effects on performance?  We will defer this analysis for now, but
leave this comment in the planning documents.


# Event Chains

An event chain is the number of events in an LP that could be executed as a group.  That
is, let t be the timestamp of a simulation cycle, how many events in the list of events
for that LP have (i) send times less than t, (ii) receive times equal or greater than t,
and (iii) that have not already been computed as part of an event chain.  Event chains can
be separated into *global chains* and *local chains*.  Global Chains are all events
regardless of the sending LP, local chains are only events that were sent by this LP.
Once a chain has been identified, the next event chain to be examined begins at the next
event following the last in the current chain.  The simultaneous computation of local and
remote event chains may prove difficult and may need to be done in separate passes over
the data.

## Global Event Chains by LPi 

This graph shows the minimum, average, and maximum length of the global event chains by
LP. 

* x-axis: labeled "LPs", enumerates the names of the LPs in the model.

* y-axis: labeled "Global Event Chain", showing (for each LP), the minimum, average, and
  maximum global event chain for that LP.

* Computed by: outline given in section "Event Chains". 

![global_event_chain_by_lp](./graphs/global_event_chain_by_lp.pdf)

## Summary of Global Event Chains

This graph shows the frequency of global event chains of length X.

* x-axis: labeled "Global Event Chain Length", enumerates the length of global event
  chains seen in the simulation.

* y-axis: labeled "Frequency of Occurrence", showing the frequency of that global event
  chain length in the entire simulation.

* Computed by: obvious.

![frequency_of_global_event_chain_by_length](./graphs/frequency_of_global_event_chain_by_length.pdf)


## Local Event Chains by LPi 

This graph shows the minimum, average, and maximum length of the local event chains by
LP. 

* x-axis: labeled "LPs", enumerates the names of the LPs in the model.

* y-axis: labeled "Local Event Chain", showing (for each LP), the minimum, average, and
  maximum local event chain for that LP.

* Computed by: outline given in section "Event Chains". 

![local_event_chain_by_lp](./graphs/local_event_chain_by_lp.pdf)

## Summary of Local Event Chains

This graph shows the frequency of local event chains of length X.

* x-axis: labeled "Local Event Chain Length", enumerates the length of local event
  chains seen in the simulation.

* y-axis: labeled "Frequency of Occurrence", showing the frequency of that local event
  chain length in the entire simulation.

* Computed by: obvious.

![frequency_of_local_event_chain_by_length](./graphs/frequency_of_local_event_chain_by_length.pdf)



# Lookahead

Lookahead is the amount of simulation time between events generated by an LP.  More
precisely if an LP sends an event with receive time of t, the lookahead is the time dt
such that the next event generated by the LP will be t + dt.  In general this time is
computed as a minimum "guaranteed" time that the receiving LP can use (in conjunction with
times from all LPs sending it messages) progress ahead in virtual time.  Basically the LP
can use the receive time and lookahead from each sending LP to determine how far forward
it can process events with a guarantee that it will not experience a causal violation.  

## Lookahead by LP

This graph shows the minimum, average, and maximum lookahead for each LP in the system. 

* x-axis: labeled "LPs", enumerates the names of the LPs in the model.

* y-axis: labeled "Lookahead", showing (for each LP), the minimum, average, and maximum
  lookahead for that LP.

* Computed by: the distance between receive times of adjacent events to the same
  destination LP.

![lookahead_by_lp](./graphs/lookahead_by_lp.pdf)

## Frequency of Lookahead

This graph shows the minimum, average, and maximum lookahead for each LP in the system. 

* x-axis: labeled "Lookahead", enumerates the values of lookahead seen.

* y-axis: labeled "Number of Occurrences", showing how often that lookahead existed
  between adjacent events for any LP in the system.

* Computed by: the distance between receive times of adjacent events to the same
  destination LP.

![lookahead_frequency](./graphs/lookahead_frequency.pdf)

